---
title: "Stats 460 Final Project"
author: "Kiri Daust"
date: "30/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(foreach)
library(tidyverse)
library(ggmcmc)
load("BayesProj.Rdata")
```


f) The goals of variable selection include a) determining which variables of not important predictors, and b) in some way removing these from the main model so they don't effect the other parameters. In frequentest statistics, once a variable is determined to not be an important predictor, it should be removed and the model rerun. The Bayesian Spike and Slab prior approach allows this to happen automatically. Once the parameter for a predictor starts to converge to zero, the Bernoulli variable ($\delta$ in our case) will switch from 1 to 0. When this happens, the full conditional distribution for $\beta$ will change to the $N(0,\epsilon)$ distribution, whose variance in this case is 6 orders of magnitude lower. Thus, once $\beta$ switches to this distribution, the variance is so low that almost all the samples stay around the mean (at zero), and because of that, these predictors have a miniscule effect on the markov chain. The name Spike and Slab is a representation of the two distributions used by $\beta$: the slab represents the higher-variance distribution used when $\delta = 1$ and the spike represents the very narrow distribution when $\delta = 0$.

```{r}
X <- dat$X
y <- dat$Y

lmfit <- lm(y ~ 0 + X) ##run linear model to get coefficients
betaLSE <- lmfit$coefficients
p <- 10
n <- 300

epsilon <- 10^(-4)
tau2 <- 10^2
api <- 1; bpi <- 1

deltaParam <- function(pi,tau2,betaj,epsilon){
  p1 <- pi*exp(-(1/(2*tau2))*betaj^2)
  p0 <- (((1-pi)*sqrt(tau2))/sqrt(epsilon))*exp(-(1/(2*epsilon))*betaj^2)
  return(p1/(p1+p0))
}

betaParam <- function(deltaj,tau2,epsilon,ysquig,x){
  if(deltaj == 1){
    num <- sum(ysquig*x)
    denom <- sum(x^2) + 1/tau2
    return(c(num/denom,1/(denom)))
  }else{
    num <- sum(ysquig*x)
    denom <- sum(x^2) + 1/epsilon
    return(c(num/denom,1/(denom)))
  }
}

calc_y <- function(beta,j){
  Xtemp <- X[,-j]
  betaTemp <- beta[-j]
  XB <- colSums(t(Xtemp)*betaTemp)
  return(y - XB)
}

mcmcGibbs <- function(numIt, api, bpi, tau2, epsilon){
  niter <- numIt
  piSim <- numeric(length = niter)
  piSim[1] <- 0.05
  deltaSim <- matrix(nrow = p, ncol = niter)
  deltaSim[,1] <- 1
  betaSim <- matrix(nrow = p, ncol = niter)
  betaSim[,1] <- betaLSE
  
  for(i in 2:niter){
    betaVec <- betaSim[,i-1]
    for(j in 1:p){
      ysquiggle <- calc_y(beta = betaVec, j = j)
      deltaSim[j,i] <- rbernoulli(1,p = deltaParam(piSim[i-1],tau2,betaVec[j],epsilon))
      bParams <- betaParam(deltaSim[j,i],tau2,epsilon,ysquiggle,X[,j])
      betaVec[j] <- bParams[1]
      # meanval[j,i] <- bParams[1]
      # sigmaval[j,i] <- bParams[2]
      betaSim[j,i] <- rnorm(1,mean = bParams[1] ,sd = sqrt(bParams[2]))
    }
    piSim[i] <- rbeta(1,api/2+sum(deltaSim[,i]),bpi/2 + p - sum(deltaSim[,i]))
  }
  return(list(beta = betaSim, pi = piSim, delta = deltaSim))
}

```

```{r convergence, fig.width=8, fig.height=10}
###create 5 chains
chainResults <-  foreach(x = 1:5, .combine = rbind) %do% {
  cat(".")
  res <- mcmcGibbs(numIt = 20000,api = 1, bpi = 1, tau2 = tau2, epsilon = epsilon)
  betaThin <- res$beta[,seq(5001,20000,by = 8)]
  betaThin <- as.data.table(t(betaThin))
  betaThin[,Iteration := seq_along(V1)]
  betaThin <- melt(betaThin,id.vars = "Iteration")
  betaThin[,Parameter := paste0("Beta_",gsub("V","",variable))]
  betaThin[,variable := NULL]
  
  deltaThin <- res$delta[,seq(5001,20000,by = 8)]
  deltaThin <- as.data.table(t(deltaThin))
  deltaThin[,Iteration := seq_along(V1)]
  deltaThin <- melt(deltaThin,id.vars = "Iteration")
  deltaThin[,Parameter := paste0("Delta_",gsub("V","",variable))]
  deltaThin[,variable := NULL]
  
  piThin <- res$pi[seq(5001,20000,by = 8)]
  piThin <- as.data.table((piThin))
  piThin[,Iteration := seq_along(V1)]
  piThin[,Parameter := "Pi"]
  setnames(piThin, old = "V1", new = "value")
  out <- rbind(betaThin,deltaThin,piThin)
  out[,Chain := x]
  out
}

deltaChain <- chainResults[grep("Delta",Parameter),]
chainResults <- chainResults[!grepl("Delta",Parameter),]

chains2 <- as_tibble(chainResults)
attr(chains2, "nChains") <- 5
attr(chains2, "nParameters") <- 11
attr(chains2, "nIterations") <- 20000
attr(chains2, "nBurnin") <- 5000
attr(chains2, "nThin") <- 8

ggobj <- ggs_traceplot(chains2)
ggobj+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

```{r delta, fig.height=3, fig.width=7}
deltaChain <- deltaChain[Parameter %in% c("Delta_1","Delta_7"),]
deltaChain[,Chain := as.factor(Chain)]
ggplot(deltaChain, aes(x = Iteration, y = value, colour = Chain))+
  geom_point()+
  facet_wrap(.~Parameter, scales = "free_y")

```

```{r rhat}
calcRhat <- function(temp){
  if(nrow(temp) %% 2 == 1){temp <- temp[-1,]}
  n = as.integer(nrow(temp)/2)
  temp <- cbind(temp[1:n,],temp[(n+1):nrow(temp),])
  m = ncol(temp)
  
  v.j <- colMeans(temp)
  v.. <- mean(v.j)
  B <- sum((v.j - v..)^2)*(n/(m-1))
  
  tempDat <- t(apply(temp, 1, FUN = function(x){(x - v.j)^2}))
  sj2 <- colSums(tempDat)/(n-1)
  W <- mean(sj2)
  
  margPostVar <- W*((n-1)/n)+B/n
  rhat <- sqrt(margPostVar/W)
  return(rhat)
}

Params <- unique(chainResults$Parameter)

rhat <- foreach(param = Params, .combine = rbind) %do% {
  dat <- chainResults[Parameter == param,]
  dat <- dcast(dat, Iteration ~ Chain, value = "value")
  dat <- as.matrix(dat[,Iteration := NULL])
  rhatVal <- calcRhat(temp = dat)
  data.table(Parameter = param, RHat = rhatVal)
}

knitr::kable(rhat)
```

```{r results, fig.width=8.5,fig.height=7}
res_good <- mcmcGibbs(numIt = 30000,api = 1, bpi = 1, tau2 = tau2, epsilon = epsilon)
betaThin <- res_good$beta[,seq(5001,30000,by = 15)]
betaThin <- as.data.table(t(betaThin))
betaThin[,Iteration := seq_along(V1)]
betaThin <- melt(betaThin,id.vars = "Iteration")
betaThin[,Parameter := paste0("Beta_",gsub("V","",variable))]
betaThin[,variable := NULL]

piThin <- res_good$pi[seq(5001,30000,by = 15)]
piThin <- as.data.table((piThin))
piThin[,Iteration := seq_along(V1)]
piThin[,Parameter := "Pi"]
setnames(piThin, old = "V1", new = "value")
resAll <- rbind(betaThin,piThin)

ggplot(resAll, aes(x = value))+
  geom_histogram(binwidth = 0.05)+
  facet_wrap(.~Parameter,scales = "free_y")

####point summaries
quants <- betaThin[,.(Quant = quantile(value,probs = c(0.05,0.25,0.5,0.75,0.95)),
                    Prob = c(0.05,0.25,0.5,0.75,0.95)), by = .(Parameter)]
quants <- dcast(quants,Prob ~ Parameter, value.var = "Quant")
knitr::kable(quants, digits = 2)

moments <- betaThin[,.(Mean = mean(value), Var = var(value)), by = .(Parameter)]
knitr::kable(moments, digits = 3)

credInt <- betaThin[,.(Quant = quantile(value,probs = c(0.025,0.975)),
                    Prob = c(0.025,0.975)), by = .(Parameter)]
credInt <- dcast(credInt,Prob ~ Parameter, value.var = "Quant")
knitr::kable(credInt, digits = 2)
```

```{r sensitivity}
##values for different priors
b1 <- c(5,1)
b2 <- c(1,3)
b3 <- c(2,2)
b4 <- c(2,5)
piParams <- cbind(b1,b2,b3,b4)

saOut <- foreach(x = 1:4, .combine = rbind) %do% {
  cat(".")
  currParams <- piParams[,x]
  res <- mcmcGibbs(numIt = 20000,api = currParams[1], bpi = currParams[2], tau2 = tau2, epsilon = epsilon)
  betaThin <- res$beta[,seq(5001,20000,by = 8)]
  betaThin <- as.data.table(t(betaThin))
  betaThin[,Iteration := seq_along(V1)]
  betaThin <- melt(betaThin,id.vars = "Iteration")
  betaThin[,Parameter := paste0("Beta_",gsub("V","",variable))]
  betaThin[,variable := NULL]
  betaThin[,PiParam := x]
  betaThin
}

xvals <- seq(0,1,by = 0.0001)
priorOut <- foreach(x = 1:4, .combine = rbind) %do% {
  currParams <- piParams[,x]
  yvals <- dbeta(xvals,currParams[1],currParams[2])
  data.table(x = xvals, y = yvals, PiParam = x)
}

ggplot(priorOut,aes(x = x, y = y))+
  geom_line()+
  facet_grid(.~PiParam)

betaVals <- saOut[Parameter %in% c("Beta_9","Beta_1","Beta_4"),]
ggplot(betaVals,aes(x = value))+
  geom_density()+
  facet_grid(Parameter ~ PiParam)
```
```{r model check, fig.width=8, fig.height = 4}
betaThin <- res_good$beta[,seq(5001,30000,by = 5)]

yrep <- matrix(nrow = 300, ncol = ncol(betaThin))
for(b in 1:ncol(betaThin)){
  betaCurr <- betaThin[,b]
  XB <- colSums(t(X)*betaCurr)
  yrepCurr <- rnorm(300,mean = XB, sd = 1)
  yrep[,b] <- yrepCurr
}

par(mfrow = c(1,2))
postMean <- colMeans(yrep)
postMed <- colMedians(yrep)
datMean <- mean(y)
datMed <- median(y)
pMean <- round(length(postMean[postMean > datMean])/length(postMean),digits = 2)
pMed <- round(length(postMed[postMed > datMed])/length(postMed),digits = 2)
hist(postMean, main = paste0("Mean: p = ",pMean))
abline(v = datMean, col = "red")
hist(postMed, main = paste0("Median: p = ",pMed))
abline(v = datMed, col = "red")
```
